Vor einem Verbindungsaufbau müssen die Rollen zugewiesen sein. Wie bereits in Sektion \ref{sec: infra topologie} erwähnt, ist es naheliegend, den Mikrocontroller als Slave bzw. Peripheral (bzgl. BLE) und Server (bzgl. TLS) zu definieren und das Smartphone als Master bzw. Central (bzgl. BLE) und Client (bzgl. TLS).
\\\\
Zur Darstellung des Verbindungsaufbaus ist im Anhang \ref{sec: anhang infra verb aufbau} S. \pageref{sec: anhang infra verb aufbau} ein Sequenzdiagramm abgebildet.

\subsubsection{Advertising/Scanning}
Zunächst muss das Peripheral mit dem Advertising beginnen. Während das Peripheral auf den drei Advertising Physical Channels periodisch Advertisments in Form eines Broadcasts sendet, scannt das Central diese Channels. Empfängt das Central ein Advertisement, muss es prüfen, ob es sich mit dem Sender des Advertisements verbinden soll. Dazu kann die Entscheidung entweder dem Nutzer oder der Anwendung überlassen werden. Je nachdem, welche Informationen das Peripheral im Advertising"=Paket angibt, kann diese Entscheidung getroffen werden. Es könnte neben der Bluetooth"=Adresse ein Geräte"=Name (Local Name) und herstellerspezifische Daten angegeben werden. Diese Informationen bezeugen nicht die Identität des Peripherals. Soll sich das Central nun zum Peripheral verbinden, sendet es einen Connection Request an das Peripheral. Das Peripheral akzeptiert die Verbindung und beide Parteien können nun über diese Verbindung auf den Piconet Physical Channels Daten übertragen. GAP steuert den Verbindungsaufbau auf Ebene des Hosts und stellt der Anwendung die verbindungsspezifischen Daten zur Verfügung. Mit diesen Daten baut die Anwendung nun eine Verbindung über L2CAP mittels eines L2CAP Connection"=Oriented Channels auf, der für den weiteren Verlauf des Verbindungsaufbaus und der Übertragung der Anwendungsdaten dient. Wie bereits in Sektion \ref{sec: infra sicherheit ble funktionen} erörtert, sollte kein Pairing und somit keine Verschlüsselung durch die BLE"=Architektur angewandt werden.

\subsubsection{TLS-Handshake}
Nun authentifizieren sich Server (Peripheral) und Client (Central) mit dem TLS"=Handshake und führen ein Schlüsselaustauschverfahren durch, um mit dem generierten Schlüssel die Anwendungsdaten zu verschlüsseln. Zu Beginn sendet der Client ein "`Client Hello"', das unter anderem die höchste unterstützte TLS"=Version, eine Zufallszahl und eine Liste der möglichen Cipher Suites enthält. Falls der Server die Version unterstützt, wählt er eine der Cipher Suites, die er auch selbst unterstützt, und sendet sie mit einer Zufallszahl an den Client ("`Server Hello"').
\\\\
Um eine beidseitige Authentifizierung zu gewährleisten, kann der Server einen "`Certificate Request"' senden. Daraufhin übermittelt der Server sein Zertifikat, das der Client mit dem Zertifikat der Zertifizierungstelle bzw. mit dessen öffentlichem Schlüssel verifiziert. Nachdem der Server sein Zertifikat übertragen hat, sendet er ein "`Certificate Verify"', das ebenfalls vom Client verifiziert wird. "`Certificate Verify"' ist eine Signatur der bisher ausgetauschten Nachrichten, die unter anderem mit dem privaten Schlüssel des Server"=Zertifikats erstellt wurde. So kann der Client mit dem öffentlichen Schlüssel des Server"=Zertifikats prüfen, ob der Server wirklich der Besitzer des besagten privaten Schlüssels ist. Da der Server zuvor einen "`Certificate Request"' gestellt hat, muss der Client nun sein Zertifikat und anschließend sein "`Certificate Verify"' senden, damit der Server beide Datensätze verifizieren kann.
\\\\
Nun sind beide Parteien authentifiziert und es wird mittels des vereinbarten Schlüsselaustauschverfahrens aus der gewählten Cipher Suite ein symmetrischer Schlüssel generiert. Anschließend werden die Anwendungsdaten mit dem vereinbarten Algorithmus aus der Cipher Suite und dem soeben generierten symmetrischen Schlüssel verschlüsselt und übertragen.